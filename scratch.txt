  -- -----------------------------------------------------
  -- Table `Tickets`
  -- -----------------------------------------------------
  DROP TABLE IF EXISTS `Tickets`;
  CREATE TABLE IF NOT EXISTS `Tickets` (
    `ticketID` INT AUTO_INCREMENT PRIMARY KEY,
    `eventID` INT NOT NULL,
    `price` DECIMAL(8,2) NOT NULL,
    `ticketHolderID` INT,
    `seatNumber` VARCHAR(5) NOT NULL,
    CONSTRAINT `uq_event_seat` UNIQUE (`eventID`, `seatNumber`),
    CONSTRAINT `fk_tickets_event` FOREIGN KEY (`eventID`)
      REFERENCES `Events`(`eventID`)
      ON UPDATE CASCADE
      ON DELETE CASCADE,
    CONSTRAINT `fk_tickets_holder` FOREIGN KEY (`ticketHolderID`)
      REFERENCES `TicketHolders`(`ticketHolderID`)
      ON UPDATE CASCADE
      ON DELETE SET NULL
  ) ENGINE = InnoDB AUTO_INCREMENT = 27;
  -- Insert data into Tickets table
  INSERT INTO `Tickets` (`eventID`, `price`, `ticketHolderID`, `seatNumber`) VALUES
  (1, 120.00, 1, 'A12'),
  (1, 95.00, 2, 'A13'),
  (2, 150.00, 1, 'B27'),
  (3, 110.00, 3, 'C9'),
  (3, 110.00, 4, 'C10');



-- #############################
-- CREATE Tickets
-- #############################
DROP PROCEDURE IF EXISTS sp_CreateTicket;

DELIMITER //
CREATE PROCEDURE sp_CreateTicket(
    IN e_eventID INT, 
    IN e_price INT,
    IN e_ticketHolderID INT,
    IN e_seatNumber INT,
    OUT e_ticketID INT)
BEGIN
    INSERT INTO Tickets (eventID, price, ticketHolderID, seatNumber) 
    VALUES (e_eventID, e_price, e_ticketHolderID, e_seatNumber);

    -- Store the ID of the last inserted row
    SELECT LAST_INSERT_ID() INTO e_ticketID;
    -- Display the ID of the last inserted ticket holder.
    SELECT LAST_INSERT_ID() AS 'ticket_id';

    -- Example of how to get the ID of the newly created person:
        -- CALL sp_CreateTicket(1, 120.00, 1, 'A12', @new_id);
        -- SELECT @new_id AS 'New Ticket ID';
END //
DELIMITER ;

-- #############################
-- UPDATE Tickets
-- #############################
DROP PROCEDURE IF EXISTS sp_UpdateTicket;
DELIMITER //

CREATE PROCEDURE sp_UpdateTicket (
  IN p_ticketID INT,
  IN p_eventID INT,
  IN p_price INT,
  IN p_ticketHolderID INT,
  IN p_seatNumber INT
)
BEGIN
  UPDATE Tickets SET eventID = p_eventID, price = e_price, ticketHolderID = e_ticketHolderID, seatNumber = e_seatNumber WHERE ticketID = e_ticketID;
END//

DELIMITER ;

-- #############################
-- DELETE Tickets
-- #############################
DROP PROCEDURE IF EXISTS sp_DeleteTicket;

DELIMITER //
CREATE PROCEDURE sp_DeleteTicket(IN e_ticketID INT)
BEGIN
    DECLARE error_message VARCHAR(255); 

    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        RESIGNAL;
    END;

    START TRANSACTION;
        -- Deleting corresponding row from Tickets table
        DELETE FROM Tickets WHERE ticketID = e_ticketID;

        -- ROW_COUNT() returns the number of rows affected by the preceding statement.
        IF ROW_COUNT() = 0 THEN
            set error_message = CONCAT('No matching record found in Tickets for ticketID: ', e_ticketID);
            -- Trigger custom error, invoke EXIT HANDLER
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = error_message;
        END IF;

    COMMIT;

END //
DELIMITER ;

app.post('/tickets/create', async function (req, res) {
    try {
        // Parse frontend form information
        const { eventID, price, ticketHolderID, seatNumber } = req.body;

        const clean = v => (Number.isNaN(v) ? null : v);
        // Create and execute our queries
        // Using parameterized queries (Prevents SQL injection attacks)
        const [results] = await db.query(
            `CALL sp_CreateTicket(?, ?, ?, ?, @new_id);`,
            [clean(eventID), clean(price), clean(ticketHolderID), clean(seatNumber)]
        );

        // Store ID of last inserted row
        let newID = null;

        // flatten all resultsets and find the one with new_id
        for (const set of results) {
            if (Array.isArray(set) && set[0] && set[0].new_id !== undefined) {
                newID = set[0].new_id;
                break;
            }
        }

        console.log(`Created Ticket with ID: ${newID}`);

        // Send success status to frontend
        res.status(200).json({ message: 'Ticket created successfully' });
    } catch (error) {
        console.error('Error executing queries:', error);
        // Send a generic error message to the browser
        res.status(500).send(
            'An error occurred while executing the database queries.'
        );
    }
});

app.put('/tickets/update/:eventID/:price', async function (req, res) {
    try {
        const { eventID, price } = req.params;
        const { newEventID, newprice, ticketHolderID, seatNumber } = req.body;

        const query1 = 'CALL sp_UpdateTicket(?, ?, ?, ?, ?, ?);';
        const query2 = 'SELECT eventID, price, ticketHolderID, seatNumber FROM Tickets WHERE eventID = ? AND price = ?;';

        await db.query(query1, [eventID, price, newEventID, newprice, ticketHolderID, seatNumber]);

        const [[rows]] = await db.query(query2, [newEventID, newprice]);

        console.log(
            `UPDATE Tickets. ID: ${rows.eventID}${rows.price}`
        );

        res.status(200).json({ message: 'Ticket updated successfully' });
    } catch (error) {
        console.error('Error executing queries:', error);
        res.status(500).send('An error occurred while executing the database queries.');
    }
});

app.delete('/tickets/:eventID/:price', async function (req, res) {
    try {
        // Parse frontend form information
        const eventID = req.params.eventID
        const price = req.params.price

        // Create and execute our query
        // Using parameterized queries (Prevents SQL injection attacks)
        const query1 = `CALL sp_DeleteTicket(?, ?);`;
        await db.query(query1, [eventID, price]);

        console.log(`DELETE Tickets. ID: ${eventID}${price}`);
        return res.sendStatus(204);
    } catch (error) {
        console.error('Error executing queries:', error);
        // Send a generic error message to the browser
        res.status(500).json({ error: 'Failed to delete player event' });
    }
});

import '../App.css';
import { MdEdit, MdDelete } from "react-icons/md";

const TicketRow = ({ ticket, onEdit, onDelete }) => {
    return (
        <tr>
            {Object.values(ticket).map((value, index) => (
                <td key={index}>{value}</td>
            ))}
            <td>
                <MdEdit onClick={e => {e.preventDefault(); onEdit(ticket);}} id="edit" />
                <MdDelete onClick={e => {e.preventDefault(); onDelete(ticket.eventID, ticket.price);}} id="delete" />
            </td>
        </tr>
    );
};

export default TicketRow;

import { useState, useEffect } from "react";
import { useNavigate } from "react-router-dom";
import TicketRow from "../components/TicketRow.jsx";

function ViewTicketsPage({ backendURL, setTicketToEdit, setPlayerToEdit, setEventToEdit }) {
    const [events, setEvents] = useState([]);
    const [players, setPlayers] = useState([]);
    const [tickets, setTickets] = useState([]);

    const navigate = useNavigate();

    const columnAliases = {
        eventID: "Event ID",
        price: "Player ID",
        ticketHolderID: "Ticket Holder ID",
        seatNumber: "Seat Number",
        fName: "First Name",
        lName: "Last Name",
        teamName: "Team Name",
        eventStart: "Event Start"
    };

    const getData = async () => {
        try {
            const [ticketsRes, eventsRes, playersRes] = await Promise.all([
                fetch(`${backendURL}/tickets`),
                fetch(`${backendURL}/events`),
                fetch(`${backendURL}/players`)
            ]);

            const eventsData = await eventsRes.json();
            const playersData = await playersRes.json();
            const ticketsData = await tickets`Res.json();

            setTickets(ticketsData.tickets || ticketsData);
            setEvents(eventsData.events || eventsData);
            setPlayers(playersData.players || playersData);
        } catch (error) {
            console.error("Error fetching data:", error);
        }
    };

    useEffect(() => {
        getData();
    }, []);

    const onCreate = async () => {
        setEventToEdit(events);
        setPlayerToEdit(players);
        navigate("/tickets/create");
    };

    const onEdit = async ticketToEdit => {
        setEventToEdit(events);
        setPlayerToEdit(players);
        setTicketToEdit(ticketToEdit);
        navigate("/tickets/update");
    };

    const onDelete = async (eventID, price) => {
        const response = await fetch(`${backendURL}/tickets/${eventID}/${price}`, { method: 'DELETE' });
        if (response.status === 204) {
            getData();
        } else {
            console.error(`Failed to delete player event with id = ${eventID}${price}, status code = ${response.status}`)
        }
    }

    return (
        <>
            <h2>List of Player Events</h2>

            <table>
                <thead>
                    <tr>
                        {tickets.length > 0 && Object.keys(tickets[0]).map((header, index) => (
                            <th key={index}>
                                {columnAliases[header] || header}
                            </th>
                        ))}
                        <th>Edit/Delete</th>
                    </tr>
                </thead>

                <tbody>
                    {tickets.map((ticket, index) => (
                        <TicketRow key={index} ticket={ticket} onEdit={onEdit} onDelete={onDelete} />
                    ))}
                </tbody>
            </table>
            <button onClick={onCreate}>Create Player Event</button>
        </>
    );
}

export default ViewTicketsPage;
